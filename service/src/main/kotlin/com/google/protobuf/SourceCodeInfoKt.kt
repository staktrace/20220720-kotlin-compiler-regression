//Generated by the protocol buffer compiler. DO NOT EDIT!
// source: google/protobuf/descriptor.proto

package com.google.protobuf;

@kotlin.jvm.JvmSynthetic
public inline fun sourceCodeInfo(block: com.google.protobuf.SourceCodeInfoKt.Dsl.() -> kotlin.Unit): com.google.protobuf.DescriptorProtos.SourceCodeInfo =
  com.google.protobuf.SourceCodeInfoKt.Dsl._create(com.google.protobuf.DescriptorProtos.SourceCodeInfo.newBuilder()).apply { block() }._build()
public object SourceCodeInfoKt {
  @kotlin.OptIn(com.google.protobuf.kotlin.OnlyForUseByGeneratedProtoCode::class)
  @com.google.protobuf.kotlin.ProtoDslMarker
  public class Dsl private constructor(
    private val _builder: com.google.protobuf.DescriptorProtos.SourceCodeInfo.Builder
  ) {
    public companion object {
      @kotlin.jvm.JvmSynthetic
      @kotlin.PublishedApi
      internal fun _create(builder: com.google.protobuf.DescriptorProtos.SourceCodeInfo.Builder): Dsl = Dsl(builder)
    }

    @kotlin.jvm.JvmSynthetic
    @kotlin.PublishedApi
    internal fun _build(): com.google.protobuf.DescriptorProtos.SourceCodeInfo = _builder.build()

    /**
     * An uninstantiable, behaviorless type to represent the field in
     * generics.
     */
    @kotlin.OptIn(com.google.protobuf.kotlin.OnlyForUseByGeneratedProtoCode::class)
    public class LocationProxy private constructor() : com.google.protobuf.kotlin.DslProxy()
    /**
     * <pre>
     * A Location identifies a piece of source code in a .proto file which
     * corresponds to a particular definition.  This information is intended
     * to be useful to IDEs, code indexers, documentation generators, and similar
     * tools.
     * For example, say we have a file like:
     *   message Foo {
     *     optional string foo = 1;
     *   }
     * Let's look at just the field definition:
     *   optional string foo = 1;
     *   ^       ^^     ^^  ^  ^^^
     *   a       bc     de  f  ghi
     * We have the following locations:
     *   span   path               represents
     *   [a,i)  [ 4, 0, 2, 0 ]     The whole field definition.
     *   [a,b)  [ 4, 0, 2, 0, 4 ]  The label (optional).
     *   [c,d)  [ 4, 0, 2, 0, 5 ]  The type (string).
     *   [e,f)  [ 4, 0, 2, 0, 1 ]  The name (foo).
     *   [g,h)  [ 4, 0, 2, 0, 3 ]  The number (1).
     * Notes:
     * - A location may refer to a repeated field itself (i.e. not to any
     *   particular index within it).  This is used whenever a set of elements are
     *   logically enclosed in a single code segment.  For example, an entire
     *   extend block (possibly containing multiple extension definitions) will
     *   have an outer location whose path refers to the "extensions" repeated
     *   field without an index.
     * - Multiple locations may have the same path.  This happens when a single
     *   logical declaration is spread out across multiple places.  The most
     *   obvious example is the "extend" block again -- there may be multiple
     *   extend blocks in the same scope, each of which will have the same path.
     * - A location's span is not always a subset of its parent's span.  For
     *   example, the "extendee" of an extension declaration appears at the
     *   beginning of the "extend" block and is shared by all extensions within
     *   the block.
     * - Just because a location's span is a subset of some other location's span
     *   does not mean that it is a descendant.  For example, a "group" defines
     *   both a type and a field in a single declaration.  Thus, the locations
     *   corresponding to the type and field and their components will overlap.
     * - Code which tries to interpret locations should probably be designed to
     *   ignore those that it doesn't understand, as more types of locations could
     *   be recorded in the future.
     * </pre>
     *
     * <code>repeated .google.protobuf.SourceCodeInfo.Location location = 1;</code>
     */
     public val location: com.google.protobuf.kotlin.DslList<com.google.protobuf.DescriptorProtos.SourceCodeInfo.Location, LocationProxy>
      @kotlin.jvm.JvmSynthetic
      get() = com.google.protobuf.kotlin.DslList(
        _builder.getLocationList()
      )
    /**
     * <pre>
     * A Location identifies a piece of source code in a .proto file which
     * corresponds to a particular definition.  This information is intended
     * to be useful to IDEs, code indexers, documentation generators, and similar
     * tools.
     * For example, say we have a file like:
     *   message Foo {
     *     optional string foo = 1;
     *   }
     * Let's look at just the field definition:
     *   optional string foo = 1;
     *   ^       ^^     ^^  ^  ^^^
     *   a       bc     de  f  ghi
     * We have the following locations:
     *   span   path               represents
     *   [a,i)  [ 4, 0, 2, 0 ]     The whole field definition.
     *   [a,b)  [ 4, 0, 2, 0, 4 ]  The label (optional).
     *   [c,d)  [ 4, 0, 2, 0, 5 ]  The type (string).
     *   [e,f)  [ 4, 0, 2, 0, 1 ]  The name (foo).
     *   [g,h)  [ 4, 0, 2, 0, 3 ]  The number (1).
     * Notes:
     * - A location may refer to a repeated field itself (i.e. not to any
     *   particular index within it).  This is used whenever a set of elements are
     *   logically enclosed in a single code segment.  For example, an entire
     *   extend block (possibly containing multiple extension definitions) will
     *   have an outer location whose path refers to the "extensions" repeated
     *   field without an index.
     * - Multiple locations may have the same path.  This happens when a single
     *   logical declaration is spread out across multiple places.  The most
     *   obvious example is the "extend" block again -- there may be multiple
     *   extend blocks in the same scope, each of which will have the same path.
     * - A location's span is not always a subset of its parent's span.  For
     *   example, the "extendee" of an extension declaration appears at the
     *   beginning of the "extend" block and is shared by all extensions within
     *   the block.
     * - Just because a location's span is a subset of some other location's span
     *   does not mean that it is a descendant.  For example, a "group" defines
     *   both a type and a field in a single declaration.  Thus, the locations
     *   corresponding to the type and field and their components will overlap.
     * - Code which tries to interpret locations should probably be designed to
     *   ignore those that it doesn't understand, as more types of locations could
     *   be recorded in the future.
     * </pre>
     *
     * <code>repeated .google.protobuf.SourceCodeInfo.Location location = 1;</code>
     * @param value The location to add.
     */
    @kotlin.jvm.JvmSynthetic
    @kotlin.jvm.JvmName("addLocation")
    public fun com.google.protobuf.kotlin.DslList<com.google.protobuf.DescriptorProtos.SourceCodeInfo.Location, LocationProxy>.add(value: com.google.protobuf.DescriptorProtos.SourceCodeInfo.Location) {
      _builder.addLocation(value)
    }/**
     * <pre>
     * A Location identifies a piece of source code in a .proto file which
     * corresponds to a particular definition.  This information is intended
     * to be useful to IDEs, code indexers, documentation generators, and similar
     * tools.
     * For example, say we have a file like:
     *   message Foo {
     *     optional string foo = 1;
     *   }
     * Let's look at just the field definition:
     *   optional string foo = 1;
     *   ^       ^^     ^^  ^  ^^^
     *   a       bc     de  f  ghi
     * We have the following locations:
     *   span   path               represents
     *   [a,i)  [ 4, 0, 2, 0 ]     The whole field definition.
     *   [a,b)  [ 4, 0, 2, 0, 4 ]  The label (optional).
     *   [c,d)  [ 4, 0, 2, 0, 5 ]  The type (string).
     *   [e,f)  [ 4, 0, 2, 0, 1 ]  The name (foo).
     *   [g,h)  [ 4, 0, 2, 0, 3 ]  The number (1).
     * Notes:
     * - A location may refer to a repeated field itself (i.e. not to any
     *   particular index within it).  This is used whenever a set of elements are
     *   logically enclosed in a single code segment.  For example, an entire
     *   extend block (possibly containing multiple extension definitions) will
     *   have an outer location whose path refers to the "extensions" repeated
     *   field without an index.
     * - Multiple locations may have the same path.  This happens when a single
     *   logical declaration is spread out across multiple places.  The most
     *   obvious example is the "extend" block again -- there may be multiple
     *   extend blocks in the same scope, each of which will have the same path.
     * - A location's span is not always a subset of its parent's span.  For
     *   example, the "extendee" of an extension declaration appears at the
     *   beginning of the "extend" block and is shared by all extensions within
     *   the block.
     * - Just because a location's span is a subset of some other location's span
     *   does not mean that it is a descendant.  For example, a "group" defines
     *   both a type and a field in a single declaration.  Thus, the locations
     *   corresponding to the type and field and their components will overlap.
     * - Code which tries to interpret locations should probably be designed to
     *   ignore those that it doesn't understand, as more types of locations could
     *   be recorded in the future.
     * </pre>
     *
     * <code>repeated .google.protobuf.SourceCodeInfo.Location location = 1;</code>
     * @param value The location to add.
     */
    @kotlin.jvm.JvmSynthetic
    @kotlin.jvm.JvmName("plusAssignLocation")
    @Suppress("NOTHING_TO_INLINE")
    public inline operator fun com.google.protobuf.kotlin.DslList<com.google.protobuf.DescriptorProtos.SourceCodeInfo.Location, LocationProxy>.plusAssign(value: com.google.protobuf.DescriptorProtos.SourceCodeInfo.Location) {
      add(value)
    }/**
     * <pre>
     * A Location identifies a piece of source code in a .proto file which
     * corresponds to a particular definition.  This information is intended
     * to be useful to IDEs, code indexers, documentation generators, and similar
     * tools.
     * For example, say we have a file like:
     *   message Foo {
     *     optional string foo = 1;
     *   }
     * Let's look at just the field definition:
     *   optional string foo = 1;
     *   ^       ^^     ^^  ^  ^^^
     *   a       bc     de  f  ghi
     * We have the following locations:
     *   span   path               represents
     *   [a,i)  [ 4, 0, 2, 0 ]     The whole field definition.
     *   [a,b)  [ 4, 0, 2, 0, 4 ]  The label (optional).
     *   [c,d)  [ 4, 0, 2, 0, 5 ]  The type (string).
     *   [e,f)  [ 4, 0, 2, 0, 1 ]  The name (foo).
     *   [g,h)  [ 4, 0, 2, 0, 3 ]  The number (1).
     * Notes:
     * - A location may refer to a repeated field itself (i.e. not to any
     *   particular index within it).  This is used whenever a set of elements are
     *   logically enclosed in a single code segment.  For example, an entire
     *   extend block (possibly containing multiple extension definitions) will
     *   have an outer location whose path refers to the "extensions" repeated
     *   field without an index.
     * - Multiple locations may have the same path.  This happens when a single
     *   logical declaration is spread out across multiple places.  The most
     *   obvious example is the "extend" block again -- there may be multiple
     *   extend blocks in the same scope, each of which will have the same path.
     * - A location's span is not always a subset of its parent's span.  For
     *   example, the "extendee" of an extension declaration appears at the
     *   beginning of the "extend" block and is shared by all extensions within
     *   the block.
     * - Just because a location's span is a subset of some other location's span
     *   does not mean that it is a descendant.  For example, a "group" defines
     *   both a type and a field in a single declaration.  Thus, the locations
     *   corresponding to the type and field and their components will overlap.
     * - Code which tries to interpret locations should probably be designed to
     *   ignore those that it doesn't understand, as more types of locations could
     *   be recorded in the future.
     * </pre>
     *
     * <code>repeated .google.protobuf.SourceCodeInfo.Location location = 1;</code>
     * @param values The location to add.
     */
    @kotlin.jvm.JvmSynthetic
    @kotlin.jvm.JvmName("addAllLocation")
    public fun com.google.protobuf.kotlin.DslList<com.google.protobuf.DescriptorProtos.SourceCodeInfo.Location, LocationProxy>.addAll(values: kotlin.collections.Iterable<com.google.protobuf.DescriptorProtos.SourceCodeInfo.Location>) {
      _builder.addAllLocation(values)
    }/**
     * <pre>
     * A Location identifies a piece of source code in a .proto file which
     * corresponds to a particular definition.  This information is intended
     * to be useful to IDEs, code indexers, documentation generators, and similar
     * tools.
     * For example, say we have a file like:
     *   message Foo {
     *     optional string foo = 1;
     *   }
     * Let's look at just the field definition:
     *   optional string foo = 1;
     *   ^       ^^     ^^  ^  ^^^
     *   a       bc     de  f  ghi
     * We have the following locations:
     *   span   path               represents
     *   [a,i)  [ 4, 0, 2, 0 ]     The whole field definition.
     *   [a,b)  [ 4, 0, 2, 0, 4 ]  The label (optional).
     *   [c,d)  [ 4, 0, 2, 0, 5 ]  The type (string).
     *   [e,f)  [ 4, 0, 2, 0, 1 ]  The name (foo).
     *   [g,h)  [ 4, 0, 2, 0, 3 ]  The number (1).
     * Notes:
     * - A location may refer to a repeated field itself (i.e. not to any
     *   particular index within it).  This is used whenever a set of elements are
     *   logically enclosed in a single code segment.  For example, an entire
     *   extend block (possibly containing multiple extension definitions) will
     *   have an outer location whose path refers to the "extensions" repeated
     *   field without an index.
     * - Multiple locations may have the same path.  This happens when a single
     *   logical declaration is spread out across multiple places.  The most
     *   obvious example is the "extend" block again -- there may be multiple
     *   extend blocks in the same scope, each of which will have the same path.
     * - A location's span is not always a subset of its parent's span.  For
     *   example, the "extendee" of an extension declaration appears at the
     *   beginning of the "extend" block and is shared by all extensions within
     *   the block.
     * - Just because a location's span is a subset of some other location's span
     *   does not mean that it is a descendant.  For example, a "group" defines
     *   both a type and a field in a single declaration.  Thus, the locations
     *   corresponding to the type and field and their components will overlap.
     * - Code which tries to interpret locations should probably be designed to
     *   ignore those that it doesn't understand, as more types of locations could
     *   be recorded in the future.
     * </pre>
     *
     * <code>repeated .google.protobuf.SourceCodeInfo.Location location = 1;</code>
     * @param values The location to add.
     */
    @kotlin.jvm.JvmSynthetic
    @kotlin.jvm.JvmName("plusAssignAllLocation")
    @Suppress("NOTHING_TO_INLINE")
    public inline operator fun com.google.protobuf.kotlin.DslList<com.google.protobuf.DescriptorProtos.SourceCodeInfo.Location, LocationProxy>.plusAssign(values: kotlin.collections.Iterable<com.google.protobuf.DescriptorProtos.SourceCodeInfo.Location>) {
      addAll(values)
    }/**
     * <pre>
     * A Location identifies a piece of source code in a .proto file which
     * corresponds to a particular definition.  This information is intended
     * to be useful to IDEs, code indexers, documentation generators, and similar
     * tools.
     * For example, say we have a file like:
     *   message Foo {
     *     optional string foo = 1;
     *   }
     * Let's look at just the field definition:
     *   optional string foo = 1;
     *   ^       ^^     ^^  ^  ^^^
     *   a       bc     de  f  ghi
     * We have the following locations:
     *   span   path               represents
     *   [a,i)  [ 4, 0, 2, 0 ]     The whole field definition.
     *   [a,b)  [ 4, 0, 2, 0, 4 ]  The label (optional).
     *   [c,d)  [ 4, 0, 2, 0, 5 ]  The type (string).
     *   [e,f)  [ 4, 0, 2, 0, 1 ]  The name (foo).
     *   [g,h)  [ 4, 0, 2, 0, 3 ]  The number (1).
     * Notes:
     * - A location may refer to a repeated field itself (i.e. not to any
     *   particular index within it).  This is used whenever a set of elements are
     *   logically enclosed in a single code segment.  For example, an entire
     *   extend block (possibly containing multiple extension definitions) will
     *   have an outer location whose path refers to the "extensions" repeated
     *   field without an index.
     * - Multiple locations may have the same path.  This happens when a single
     *   logical declaration is spread out across multiple places.  The most
     *   obvious example is the "extend" block again -- there may be multiple
     *   extend blocks in the same scope, each of which will have the same path.
     * - A location's span is not always a subset of its parent's span.  For
     *   example, the "extendee" of an extension declaration appears at the
     *   beginning of the "extend" block and is shared by all extensions within
     *   the block.
     * - Just because a location's span is a subset of some other location's span
     *   does not mean that it is a descendant.  For example, a "group" defines
     *   both a type and a field in a single declaration.  Thus, the locations
     *   corresponding to the type and field and their components will overlap.
     * - Code which tries to interpret locations should probably be designed to
     *   ignore those that it doesn't understand, as more types of locations could
     *   be recorded in the future.
     * </pre>
     *
     * <code>repeated .google.protobuf.SourceCodeInfo.Location location = 1;</code>
     * @param index The index to set the value at.
     * @param value The location to set.
     */
    @kotlin.jvm.JvmSynthetic
    @kotlin.jvm.JvmName("setLocation")
    public operator fun com.google.protobuf.kotlin.DslList<com.google.protobuf.DescriptorProtos.SourceCodeInfo.Location, LocationProxy>.set(index: kotlin.Int, value: com.google.protobuf.DescriptorProtos.SourceCodeInfo.Location) {
      _builder.setLocation(index, value)
    }/**
     * <pre>
     * A Location identifies a piece of source code in a .proto file which
     * corresponds to a particular definition.  This information is intended
     * to be useful to IDEs, code indexers, documentation generators, and similar
     * tools.
     * For example, say we have a file like:
     *   message Foo {
     *     optional string foo = 1;
     *   }
     * Let's look at just the field definition:
     *   optional string foo = 1;
     *   ^       ^^     ^^  ^  ^^^
     *   a       bc     de  f  ghi
     * We have the following locations:
     *   span   path               represents
     *   [a,i)  [ 4, 0, 2, 0 ]     The whole field definition.
     *   [a,b)  [ 4, 0, 2, 0, 4 ]  The label (optional).
     *   [c,d)  [ 4, 0, 2, 0, 5 ]  The type (string).
     *   [e,f)  [ 4, 0, 2, 0, 1 ]  The name (foo).
     *   [g,h)  [ 4, 0, 2, 0, 3 ]  The number (1).
     * Notes:
     * - A location may refer to a repeated field itself (i.e. not to any
     *   particular index within it).  This is used whenever a set of elements are
     *   logically enclosed in a single code segment.  For example, an entire
     *   extend block (possibly containing multiple extension definitions) will
     *   have an outer location whose path refers to the "extensions" repeated
     *   field without an index.
     * - Multiple locations may have the same path.  This happens when a single
     *   logical declaration is spread out across multiple places.  The most
     *   obvious example is the "extend" block again -- there may be multiple
     *   extend blocks in the same scope, each of which will have the same path.
     * - A location's span is not always a subset of its parent's span.  For
     *   example, the "extendee" of an extension declaration appears at the
     *   beginning of the "extend" block and is shared by all extensions within
     *   the block.
     * - Just because a location's span is a subset of some other location's span
     *   does not mean that it is a descendant.  For example, a "group" defines
     *   both a type and a field in a single declaration.  Thus, the locations
     *   corresponding to the type and field and their components will overlap.
     * - Code which tries to interpret locations should probably be designed to
     *   ignore those that it doesn't understand, as more types of locations could
     *   be recorded in the future.
     * </pre>
     *
     * <code>repeated .google.protobuf.SourceCodeInfo.Location location = 1;</code>
     */
    @kotlin.jvm.JvmSynthetic
    @kotlin.jvm.JvmName("clearLocation")
    public fun com.google.protobuf.kotlin.DslList<com.google.protobuf.DescriptorProtos.SourceCodeInfo.Location, LocationProxy>.clear() {
      _builder.clearLocation()
    }}
  @kotlin.jvm.JvmSynthetic
  public inline fun location(block: com.google.protobuf.SourceCodeInfoKt.LocationKt.Dsl.() -> kotlin.Unit): com.google.protobuf.DescriptorProtos.SourceCodeInfo.Location =
    com.google.protobuf.SourceCodeInfoKt.LocationKt.Dsl._create(com.google.protobuf.DescriptorProtos.SourceCodeInfo.Location.newBuilder()).apply { block() }._build()
  public object LocationKt {
    @kotlin.OptIn(com.google.protobuf.kotlin.OnlyForUseByGeneratedProtoCode::class)
    @com.google.protobuf.kotlin.ProtoDslMarker
    public class Dsl private constructor(
      private val _builder: com.google.protobuf.DescriptorProtos.SourceCodeInfo.Location.Builder
    ) {
      public companion object {
        @kotlin.jvm.JvmSynthetic
        @kotlin.PublishedApi
        internal fun _create(builder: com.google.protobuf.DescriptorProtos.SourceCodeInfo.Location.Builder): Dsl = Dsl(builder)
      }

      @kotlin.jvm.JvmSynthetic
      @kotlin.PublishedApi
      internal fun _build(): com.google.protobuf.DescriptorProtos.SourceCodeInfo.Location = _builder.build()

      /**
       * An uninstantiable, behaviorless type to represent the field in
       * generics.
       */
      @kotlin.OptIn(com.google.protobuf.kotlin.OnlyForUseByGeneratedProtoCode::class)
      public class PathProxy private constructor() : com.google.protobuf.kotlin.DslProxy()
      /**
       * <pre>
       * Identifies which part of the FileDescriptorProto was defined at this
       * location.
       * Each element is a field number or an index.  They form a path from
       * the root FileDescriptorProto to the place where the definition.  For
       * example, this path:
       *   [ 4, 3, 2, 7, 1 ]
       * refers to:
       *   file.message_type(3)  // 4, 3
       *       .field(7)         // 2, 7
       *       .name()           // 1
       * This is because FileDescriptorProto.message_type has field number 4:
       *   repeated DescriptorProto message_type = 4;
       * and DescriptorProto.field has field number 2:
       *   repeated FieldDescriptorProto field = 2;
       * and FieldDescriptorProto.name has field number 1:
       *   optional string name = 1;
       * Thus, the above path gives the location of a field name.  If we removed
       * the last element:
       *   [ 4, 3, 2, 7 ]
       * this path refers to the whole field declaration (from the beginning
       * of the label to the terminating semicolon).
       * </pre>
       *
       * <code>repeated int32 path = 1 [packed = true];</code>
       */
       public val path: com.google.protobuf.kotlin.DslList<kotlin.Int, PathProxy>
        @kotlin.jvm.JvmSynthetic
        get() = com.google.protobuf.kotlin.DslList(
          _builder.getPathList()
        )
      /**
       * <pre>
       * Identifies which part of the FileDescriptorProto was defined at this
       * location.
       * Each element is a field number or an index.  They form a path from
       * the root FileDescriptorProto to the place where the definition.  For
       * example, this path:
       *   [ 4, 3, 2, 7, 1 ]
       * refers to:
       *   file.message_type(3)  // 4, 3
       *       .field(7)         // 2, 7
       *       .name()           // 1
       * This is because FileDescriptorProto.message_type has field number 4:
       *   repeated DescriptorProto message_type = 4;
       * and DescriptorProto.field has field number 2:
       *   repeated FieldDescriptorProto field = 2;
       * and FieldDescriptorProto.name has field number 1:
       *   optional string name = 1;
       * Thus, the above path gives the location of a field name.  If we removed
       * the last element:
       *   [ 4, 3, 2, 7 ]
       * this path refers to the whole field declaration (from the beginning
       * of the label to the terminating semicolon).
       * </pre>
       *
       * <code>repeated int32 path = 1 [packed = true];</code>
       * @param value The path to add.
       */
      @kotlin.jvm.JvmSynthetic
      @kotlin.jvm.JvmName("addPath")
      public fun com.google.protobuf.kotlin.DslList<kotlin.Int, PathProxy>.add(value: kotlin.Int) {
        _builder.addPath(value)
      }/**
       * <pre>
       * Identifies which part of the FileDescriptorProto was defined at this
       * location.
       * Each element is a field number or an index.  They form a path from
       * the root FileDescriptorProto to the place where the definition.  For
       * example, this path:
       *   [ 4, 3, 2, 7, 1 ]
       * refers to:
       *   file.message_type(3)  // 4, 3
       *       .field(7)         // 2, 7
       *       .name()           // 1
       * This is because FileDescriptorProto.message_type has field number 4:
       *   repeated DescriptorProto message_type = 4;
       * and DescriptorProto.field has field number 2:
       *   repeated FieldDescriptorProto field = 2;
       * and FieldDescriptorProto.name has field number 1:
       *   optional string name = 1;
       * Thus, the above path gives the location of a field name.  If we removed
       * the last element:
       *   [ 4, 3, 2, 7 ]
       * this path refers to the whole field declaration (from the beginning
       * of the label to the terminating semicolon).
       * </pre>
       *
       * <code>repeated int32 path = 1 [packed = true];</code>
       * @param value The path to add.
       */
      @kotlin.jvm.JvmSynthetic
      @kotlin.jvm.JvmName("plusAssignPath")
      @Suppress("NOTHING_TO_INLINE")
      public inline operator fun com.google.protobuf.kotlin.DslList<kotlin.Int, PathProxy>.plusAssign(value: kotlin.Int) {
        add(value)
      }/**
       * <pre>
       * Identifies which part of the FileDescriptorProto was defined at this
       * location.
       * Each element is a field number or an index.  They form a path from
       * the root FileDescriptorProto to the place where the definition.  For
       * example, this path:
       *   [ 4, 3, 2, 7, 1 ]
       * refers to:
       *   file.message_type(3)  // 4, 3
       *       .field(7)         // 2, 7
       *       .name()           // 1
       * This is because FileDescriptorProto.message_type has field number 4:
       *   repeated DescriptorProto message_type = 4;
       * and DescriptorProto.field has field number 2:
       *   repeated FieldDescriptorProto field = 2;
       * and FieldDescriptorProto.name has field number 1:
       *   optional string name = 1;
       * Thus, the above path gives the location of a field name.  If we removed
       * the last element:
       *   [ 4, 3, 2, 7 ]
       * this path refers to the whole field declaration (from the beginning
       * of the label to the terminating semicolon).
       * </pre>
       *
       * <code>repeated int32 path = 1 [packed = true];</code>
       * @param values The path to add.
       */
      @kotlin.jvm.JvmSynthetic
      @kotlin.jvm.JvmName("addAllPath")
      public fun com.google.protobuf.kotlin.DslList<kotlin.Int, PathProxy>.addAll(values: kotlin.collections.Iterable<kotlin.Int>) {
        _builder.addAllPath(values)
      }/**
       * <pre>
       * Identifies which part of the FileDescriptorProto was defined at this
       * location.
       * Each element is a field number or an index.  They form a path from
       * the root FileDescriptorProto to the place where the definition.  For
       * example, this path:
       *   [ 4, 3, 2, 7, 1 ]
       * refers to:
       *   file.message_type(3)  // 4, 3
       *       .field(7)         // 2, 7
       *       .name()           // 1
       * This is because FileDescriptorProto.message_type has field number 4:
       *   repeated DescriptorProto message_type = 4;
       * and DescriptorProto.field has field number 2:
       *   repeated FieldDescriptorProto field = 2;
       * and FieldDescriptorProto.name has field number 1:
       *   optional string name = 1;
       * Thus, the above path gives the location of a field name.  If we removed
       * the last element:
       *   [ 4, 3, 2, 7 ]
       * this path refers to the whole field declaration (from the beginning
       * of the label to the terminating semicolon).
       * </pre>
       *
       * <code>repeated int32 path = 1 [packed = true];</code>
       * @param values The path to add.
       */
      @kotlin.jvm.JvmSynthetic
      @kotlin.jvm.JvmName("plusAssignAllPath")
      @Suppress("NOTHING_TO_INLINE")
      public inline operator fun com.google.protobuf.kotlin.DslList<kotlin.Int, PathProxy>.plusAssign(values: kotlin.collections.Iterable<kotlin.Int>) {
        addAll(values)
      }/**
       * <pre>
       * Identifies which part of the FileDescriptorProto was defined at this
       * location.
       * Each element is a field number or an index.  They form a path from
       * the root FileDescriptorProto to the place where the definition.  For
       * example, this path:
       *   [ 4, 3, 2, 7, 1 ]
       * refers to:
       *   file.message_type(3)  // 4, 3
       *       .field(7)         // 2, 7
       *       .name()           // 1
       * This is because FileDescriptorProto.message_type has field number 4:
       *   repeated DescriptorProto message_type = 4;
       * and DescriptorProto.field has field number 2:
       *   repeated FieldDescriptorProto field = 2;
       * and FieldDescriptorProto.name has field number 1:
       *   optional string name = 1;
       * Thus, the above path gives the location of a field name.  If we removed
       * the last element:
       *   [ 4, 3, 2, 7 ]
       * this path refers to the whole field declaration (from the beginning
       * of the label to the terminating semicolon).
       * </pre>
       *
       * <code>repeated int32 path = 1 [packed = true];</code>
       * @param index The index to set the value at.
       * @param value The path to set.
       */
      @kotlin.jvm.JvmSynthetic
      @kotlin.jvm.JvmName("setPath")
      public operator fun com.google.protobuf.kotlin.DslList<kotlin.Int, PathProxy>.set(index: kotlin.Int, value: kotlin.Int) {
        _builder.setPath(index, value)
      }/**
       * <pre>
       * Identifies which part of the FileDescriptorProto was defined at this
       * location.
       * Each element is a field number or an index.  They form a path from
       * the root FileDescriptorProto to the place where the definition.  For
       * example, this path:
       *   [ 4, 3, 2, 7, 1 ]
       * refers to:
       *   file.message_type(3)  // 4, 3
       *       .field(7)         // 2, 7
       *       .name()           // 1
       * This is because FileDescriptorProto.message_type has field number 4:
       *   repeated DescriptorProto message_type = 4;
       * and DescriptorProto.field has field number 2:
       *   repeated FieldDescriptorProto field = 2;
       * and FieldDescriptorProto.name has field number 1:
       *   optional string name = 1;
       * Thus, the above path gives the location of a field name.  If we removed
       * the last element:
       *   [ 4, 3, 2, 7 ]
       * this path refers to the whole field declaration (from the beginning
       * of the label to the terminating semicolon).
       * </pre>
       *
       * <code>repeated int32 path = 1 [packed = true];</code>
       */
      @kotlin.jvm.JvmSynthetic
      @kotlin.jvm.JvmName("clearPath")
      public fun com.google.protobuf.kotlin.DslList<kotlin.Int, PathProxy>.clear() {
        _builder.clearPath()
      }
      /**
       * An uninstantiable, behaviorless type to represent the field in
       * generics.
       */
      @kotlin.OptIn(com.google.protobuf.kotlin.OnlyForUseByGeneratedProtoCode::class)
      public class SpanProxy private constructor() : com.google.protobuf.kotlin.DslProxy()
      /**
       * <pre>
       * Always has exactly three or four elements: start line, start column,
       * end line (optional, otherwise assumed same as start line), end column.
       * These are packed into a single field for efficiency.  Note that line
       * and column numbers are zero-based -- typically you will want to add
       * 1 to each before displaying to a user.
       * </pre>
       *
       * <code>repeated int32 span = 2 [packed = true];</code>
       */
       public val span: com.google.protobuf.kotlin.DslList<kotlin.Int, SpanProxy>
        @kotlin.jvm.JvmSynthetic
        get() = com.google.protobuf.kotlin.DslList(
          _builder.getSpanList()
        )
      /**
       * <pre>
       * Always has exactly three or four elements: start line, start column,
       * end line (optional, otherwise assumed same as start line), end column.
       * These are packed into a single field for efficiency.  Note that line
       * and column numbers are zero-based -- typically you will want to add
       * 1 to each before displaying to a user.
       * </pre>
       *
       * <code>repeated int32 span = 2 [packed = true];</code>
       * @param value The span to add.
       */
      @kotlin.jvm.JvmSynthetic
      @kotlin.jvm.JvmName("addSpan")
      public fun com.google.protobuf.kotlin.DslList<kotlin.Int, SpanProxy>.add(value: kotlin.Int) {
        _builder.addSpan(value)
      }/**
       * <pre>
       * Always has exactly three or four elements: start line, start column,
       * end line (optional, otherwise assumed same as start line), end column.
       * These are packed into a single field for efficiency.  Note that line
       * and column numbers are zero-based -- typically you will want to add
       * 1 to each before displaying to a user.
       * </pre>
       *
       * <code>repeated int32 span = 2 [packed = true];</code>
       * @param value The span to add.
       */
      @kotlin.jvm.JvmSynthetic
      @kotlin.jvm.JvmName("plusAssignSpan")
      @Suppress("NOTHING_TO_INLINE")
      public inline operator fun com.google.protobuf.kotlin.DslList<kotlin.Int, SpanProxy>.plusAssign(value: kotlin.Int) {
        add(value)
      }/**
       * <pre>
       * Always has exactly three or four elements: start line, start column,
       * end line (optional, otherwise assumed same as start line), end column.
       * These are packed into a single field for efficiency.  Note that line
       * and column numbers are zero-based -- typically you will want to add
       * 1 to each before displaying to a user.
       * </pre>
       *
       * <code>repeated int32 span = 2 [packed = true];</code>
       * @param values The span to add.
       */
      @kotlin.jvm.JvmSynthetic
      @kotlin.jvm.JvmName("addAllSpan")
      public fun com.google.protobuf.kotlin.DslList<kotlin.Int, SpanProxy>.addAll(values: kotlin.collections.Iterable<kotlin.Int>) {
        _builder.addAllSpan(values)
      }/**
       * <pre>
       * Always has exactly three or four elements: start line, start column,
       * end line (optional, otherwise assumed same as start line), end column.
       * These are packed into a single field for efficiency.  Note that line
       * and column numbers are zero-based -- typically you will want to add
       * 1 to each before displaying to a user.
       * </pre>
       *
       * <code>repeated int32 span = 2 [packed = true];</code>
       * @param values The span to add.
       */
      @kotlin.jvm.JvmSynthetic
      @kotlin.jvm.JvmName("plusAssignAllSpan")
      @Suppress("NOTHING_TO_INLINE")
      public inline operator fun com.google.protobuf.kotlin.DslList<kotlin.Int, SpanProxy>.plusAssign(values: kotlin.collections.Iterable<kotlin.Int>) {
        addAll(values)
      }/**
       * <pre>
       * Always has exactly three or four elements: start line, start column,
       * end line (optional, otherwise assumed same as start line), end column.
       * These are packed into a single field for efficiency.  Note that line
       * and column numbers are zero-based -- typically you will want to add
       * 1 to each before displaying to a user.
       * </pre>
       *
       * <code>repeated int32 span = 2 [packed = true];</code>
       * @param index The index to set the value at.
       * @param value The span to set.
       */
      @kotlin.jvm.JvmSynthetic
      @kotlin.jvm.JvmName("setSpan")
      public operator fun com.google.protobuf.kotlin.DslList<kotlin.Int, SpanProxy>.set(index: kotlin.Int, value: kotlin.Int) {
        _builder.setSpan(index, value)
      }/**
       * <pre>
       * Always has exactly three or four elements: start line, start column,
       * end line (optional, otherwise assumed same as start line), end column.
       * These are packed into a single field for efficiency.  Note that line
       * and column numbers are zero-based -- typically you will want to add
       * 1 to each before displaying to a user.
       * </pre>
       *
       * <code>repeated int32 span = 2 [packed = true];</code>
       */
      @kotlin.jvm.JvmSynthetic
      @kotlin.jvm.JvmName("clearSpan")
      public fun com.google.protobuf.kotlin.DslList<kotlin.Int, SpanProxy>.clear() {
        _builder.clearSpan()
      }
      /**
       * <pre>
       * If this SourceCodeInfo represents a complete declaration, these are any
       * comments appearing before and after the declaration which appear to be
       * attached to the declaration.
       * A series of line comments appearing on consecutive lines, with no other
       * tokens appearing on those lines, will be treated as a single comment.
       * leading_detached_comments will keep paragraphs of comments that appear
       * before (but not connected to) the current element. Each paragraph,
       * separated by empty lines, will be one comment element in the repeated
       * field.
       * Only the comment content is provided; comment markers (e.g. //) are
       * stripped out.  For block comments, leading whitespace and an asterisk
       * will be stripped from the beginning of each line other than the first.
       * Newlines are included in the output.
       * Examples:
       *   optional int32 foo = 1;  // Comment attached to foo.
       *   // Comment attached to bar.
       *   optional int32 bar = 2;
       *   optional string baz = 3;
       *   // Comment attached to baz.
       *   // Another line attached to baz.
       *   // Comment attached to qux.
       *   //
       *   // Another line attached to qux.
       *   optional double qux = 4;
       *   // Detached comment for corge. This is not leading or trailing comments
       *   // to qux or corge because there are blank lines separating it from
       *   // both.
       *   // Detached comment for corge paragraph 2.
       *   optional string corge = 5;
       *   /&#42; Block comment attached
       *    * to corge.  Leading asterisks
       *    * will be removed. *&#47;
       *   /&#42; Block comment attached to
       *    * grault. *&#47;
       *   optional int32 grault = 6;
       *   // ignored detached comments.
       * </pre>
       *
       * <code>optional string leading_comments = 3;</code>
       */
      public var leadingComments: kotlin.String
        @JvmName("getLeadingComments")
        get() = _builder.getLeadingComments()
        @JvmName("setLeadingComments")
        set(value) {
          _builder.setLeadingComments(value)
        }
      /**
       * <pre>
       * If this SourceCodeInfo represents a complete declaration, these are any
       * comments appearing before and after the declaration which appear to be
       * attached to the declaration.
       * A series of line comments appearing on consecutive lines, with no other
       * tokens appearing on those lines, will be treated as a single comment.
       * leading_detached_comments will keep paragraphs of comments that appear
       * before (but not connected to) the current element. Each paragraph,
       * separated by empty lines, will be one comment element in the repeated
       * field.
       * Only the comment content is provided; comment markers (e.g. //) are
       * stripped out.  For block comments, leading whitespace and an asterisk
       * will be stripped from the beginning of each line other than the first.
       * Newlines are included in the output.
       * Examples:
       *   optional int32 foo = 1;  // Comment attached to foo.
       *   // Comment attached to bar.
       *   optional int32 bar = 2;
       *   optional string baz = 3;
       *   // Comment attached to baz.
       *   // Another line attached to baz.
       *   // Comment attached to qux.
       *   //
       *   // Another line attached to qux.
       *   optional double qux = 4;
       *   // Detached comment for corge. This is not leading or trailing comments
       *   // to qux or corge because there are blank lines separating it from
       *   // both.
       *   // Detached comment for corge paragraph 2.
       *   optional string corge = 5;
       *   /&#42; Block comment attached
       *    * to corge.  Leading asterisks
       *    * will be removed. *&#47;
       *   /&#42; Block comment attached to
       *    * grault. *&#47;
       *   optional int32 grault = 6;
       *   // ignored detached comments.
       * </pre>
       *
       * <code>optional string leading_comments = 3;</code>
       */
      public fun clearLeadingComments() {
        _builder.clearLeadingComments()
      }
      /**
       * <pre>
       * If this SourceCodeInfo represents a complete declaration, these are any
       * comments appearing before and after the declaration which appear to be
       * attached to the declaration.
       * A series of line comments appearing on consecutive lines, with no other
       * tokens appearing on those lines, will be treated as a single comment.
       * leading_detached_comments will keep paragraphs of comments that appear
       * before (but not connected to) the current element. Each paragraph,
       * separated by empty lines, will be one comment element in the repeated
       * field.
       * Only the comment content is provided; comment markers (e.g. //) are
       * stripped out.  For block comments, leading whitespace and an asterisk
       * will be stripped from the beginning of each line other than the first.
       * Newlines are included in the output.
       * Examples:
       *   optional int32 foo = 1;  // Comment attached to foo.
       *   // Comment attached to bar.
       *   optional int32 bar = 2;
       *   optional string baz = 3;
       *   // Comment attached to baz.
       *   // Another line attached to baz.
       *   // Comment attached to qux.
       *   //
       *   // Another line attached to qux.
       *   optional double qux = 4;
       *   // Detached comment for corge. This is not leading or trailing comments
       *   // to qux or corge because there are blank lines separating it from
       *   // both.
       *   // Detached comment for corge paragraph 2.
       *   optional string corge = 5;
       *   /&#42; Block comment attached
       *    * to corge.  Leading asterisks
       *    * will be removed. *&#47;
       *   /&#42; Block comment attached to
       *    * grault. *&#47;
       *   optional int32 grault = 6;
       *   // ignored detached comments.
       * </pre>
       *
       * <code>optional string leading_comments = 3;</code>
       * @return Whether the leadingComments field is set.
       */
      public fun hasLeadingComments(): kotlin.Boolean {
        return _builder.hasLeadingComments()
      }

      /**
       * <code>optional string trailing_comments = 4;</code>
       */
      public var trailingComments: kotlin.String
        @JvmName("getTrailingComments")
        get() = _builder.getTrailingComments()
        @JvmName("setTrailingComments")
        set(value) {
          _builder.setTrailingComments(value)
        }
      /**
       * <code>optional string trailing_comments = 4;</code>
       */
      public fun clearTrailingComments() {
        _builder.clearTrailingComments()
      }
      /**
       * <code>optional string trailing_comments = 4;</code>
       * @return Whether the trailingComments field is set.
       */
      public fun hasTrailingComments(): kotlin.Boolean {
        return _builder.hasTrailingComments()
      }

      /**
       * An uninstantiable, behaviorless type to represent the field in
       * generics.
       */
      @kotlin.OptIn(com.google.protobuf.kotlin.OnlyForUseByGeneratedProtoCode::class)
      public class LeadingDetachedCommentsProxy private constructor() : com.google.protobuf.kotlin.DslProxy()
      /**
       * <code>repeated string leading_detached_comments = 6;</code>
       * @return A list containing the leadingDetachedComments.
       */
      public val leadingDetachedComments: com.google.protobuf.kotlin.DslList<kotlin.String, LeadingDetachedCommentsProxy>
        @kotlin.jvm.JvmSynthetic
        get() = com.google.protobuf.kotlin.DslList(
          _builder.getLeadingDetachedCommentsList()
        )
      /**
       * <code>repeated string leading_detached_comments = 6;</code>
       * @param value The leadingDetachedComments to add.
       */
      @kotlin.jvm.JvmSynthetic
      @kotlin.jvm.JvmName("addLeadingDetachedComments")
      public fun com.google.protobuf.kotlin.DslList<kotlin.String, LeadingDetachedCommentsProxy>.add(value: kotlin.String) {
        _builder.addLeadingDetachedComments(value)
      }
      /**
       * <code>repeated string leading_detached_comments = 6;</code>
       * @param value The leadingDetachedComments to add.
       */
      @kotlin.jvm.JvmSynthetic
      @kotlin.jvm.JvmName("plusAssignLeadingDetachedComments")
      @Suppress("NOTHING_TO_INLINE")
      public inline operator fun com.google.protobuf.kotlin.DslList<kotlin.String, LeadingDetachedCommentsProxy>.plusAssign(value: kotlin.String) {
        add(value)
      }
      /**
       * <code>repeated string leading_detached_comments = 6;</code>
       * @param values The leadingDetachedComments to add.
       */
      @kotlin.jvm.JvmSynthetic
      @kotlin.jvm.JvmName("addAllLeadingDetachedComments")
      public fun com.google.protobuf.kotlin.DslList<kotlin.String, LeadingDetachedCommentsProxy>.addAll(values: kotlin.collections.Iterable<kotlin.String>) {
        _builder.addAllLeadingDetachedComments(values)
      }
      /**
       * <code>repeated string leading_detached_comments = 6;</code>
       * @param values The leadingDetachedComments to add.
       */
      @kotlin.jvm.JvmSynthetic
      @kotlin.jvm.JvmName("plusAssignAllLeadingDetachedComments")
      @Suppress("NOTHING_TO_INLINE")
      public inline operator fun com.google.protobuf.kotlin.DslList<kotlin.String, LeadingDetachedCommentsProxy>.plusAssign(values: kotlin.collections.Iterable<kotlin.String>) {
        addAll(values)
      }
      /**
       * <code>repeated string leading_detached_comments = 6;</code>
       * @param index The index to set the value at.
       * @param value The leadingDetachedComments to set.
       */
      @kotlin.jvm.JvmSynthetic
      @kotlin.jvm.JvmName("setLeadingDetachedComments")
      public operator fun com.google.protobuf.kotlin.DslList<kotlin.String, LeadingDetachedCommentsProxy>.set(index: kotlin.Int, value: kotlin.String) {
        _builder.setLeadingDetachedComments(index, value)
      }/**
       * <code>repeated string leading_detached_comments = 6;</code>
       */
      @kotlin.jvm.JvmSynthetic
      @kotlin.jvm.JvmName("clearLeadingDetachedComments")
      public fun com.google.protobuf.kotlin.DslList<kotlin.String, LeadingDetachedCommentsProxy>.clear() {
        _builder.clearLeadingDetachedComments()
      }}
  }
}
@kotlin.jvm.JvmSynthetic
public inline fun com.google.protobuf.DescriptorProtos.SourceCodeInfo.copy(block: com.google.protobuf.SourceCodeInfoKt.Dsl.() -> kotlin.Unit): com.google.protobuf.DescriptorProtos.SourceCodeInfo =
  com.google.protobuf.SourceCodeInfoKt.Dsl._create(this.toBuilder()).apply { block() }._build()
@kotlin.jvm.JvmSynthetic
public inline fun com.google.protobuf.DescriptorProtos.SourceCodeInfo.Location.copy(block: com.google.protobuf.SourceCodeInfoKt.LocationKt.Dsl.() -> kotlin.Unit): com.google.protobuf.DescriptorProtos.SourceCodeInfo.Location =
  com.google.protobuf.SourceCodeInfoKt.LocationKt.Dsl._create(this.toBuilder()).apply { block() }._build()
