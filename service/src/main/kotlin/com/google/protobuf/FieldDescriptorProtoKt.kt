//Generated by the protocol buffer compiler. DO NOT EDIT!
// source: google/protobuf/descriptor.proto

package com.google.protobuf;

@kotlin.jvm.JvmSynthetic
public inline fun fieldDescriptorProto(block: com.google.protobuf.FieldDescriptorProtoKt.Dsl.() -> kotlin.Unit): com.google.protobuf.DescriptorProtos.FieldDescriptorProto =
  com.google.protobuf.FieldDescriptorProtoKt.Dsl._create(com.google.protobuf.DescriptorProtos.FieldDescriptorProto.newBuilder()).apply { block() }._build()
public object FieldDescriptorProtoKt {
  @kotlin.OptIn(com.google.protobuf.kotlin.OnlyForUseByGeneratedProtoCode::class)
  @com.google.protobuf.kotlin.ProtoDslMarker
  public class Dsl private constructor(
    private val _builder: com.google.protobuf.DescriptorProtos.FieldDescriptorProto.Builder
  ) {
    public companion object {
      @kotlin.jvm.JvmSynthetic
      @kotlin.PublishedApi
      internal fun _create(builder: com.google.protobuf.DescriptorProtos.FieldDescriptorProto.Builder): Dsl = Dsl(builder)
    }

    @kotlin.jvm.JvmSynthetic
    @kotlin.PublishedApi
    internal fun _build(): com.google.protobuf.DescriptorProtos.FieldDescriptorProto = _builder.build()

    /**
     * <code>optional string name = 1;</code>
     */
    public var name: kotlin.String
      @JvmName("getName")
      get() = _builder.getName()
      @JvmName("setName")
      set(value) {
        _builder.setName(value)
      }
    /**
     * <code>optional string name = 1;</code>
     */
    public fun clearName() {
      _builder.clearName()
    }
    /**
     * <code>optional string name = 1;</code>
     * @return Whether the name field is set.
     */
    public fun hasName(): kotlin.Boolean {
      return _builder.hasName()
    }

    /**
     * <code>optional int32 number = 3;</code>
     */
    public var number: kotlin.Int
      @JvmName("getNumber")
      get() = _builder.getNumber()
      @JvmName("setNumber")
      set(value) {
        _builder.setNumber(value)
      }
    /**
     * <code>optional int32 number = 3;</code>
     */
    public fun clearNumber() {
      _builder.clearNumber()
    }
    /**
     * <code>optional int32 number = 3;</code>
     * @return Whether the number field is set.
     */
    public fun hasNumber(): kotlin.Boolean {
      return _builder.hasNumber()
    }

    /**
     * <code>optional .google.protobuf.FieldDescriptorProto.Label label = 4;</code>
     */
    public var label: com.google.protobuf.DescriptorProtos.FieldDescriptorProto.Label
      @JvmName("getLabel")
      get() = _builder.getLabel()
      @JvmName("setLabel")
      set(value) {
        _builder.setLabel(value)
      }
    /**
     * <code>optional .google.protobuf.FieldDescriptorProto.Label label = 4;</code>
     */
    public fun clearLabel() {
      _builder.clearLabel()
    }
    /**
     * <code>optional .google.protobuf.FieldDescriptorProto.Label label = 4;</code>
     * @return Whether the label field is set.
     */
    public fun hasLabel(): kotlin.Boolean {
      return _builder.hasLabel()
    }

    /**
     * <pre>
     * If type_name is set, this need not be set.  If both this and type_name
     * are set, this must be one of TYPE_ENUM, TYPE_MESSAGE or TYPE_GROUP.
     * </pre>
     *
     * <code>optional .google.protobuf.FieldDescriptorProto.Type type = 5;</code>
     */
    public var type: com.google.protobuf.DescriptorProtos.FieldDescriptorProto.Type
      @JvmName("getType")
      get() = _builder.getType()
      @JvmName("setType")
      set(value) {
        _builder.setType(value)
      }
    /**
     * <pre>
     * If type_name is set, this need not be set.  If both this and type_name
     * are set, this must be one of TYPE_ENUM, TYPE_MESSAGE or TYPE_GROUP.
     * </pre>
     *
     * <code>optional .google.protobuf.FieldDescriptorProto.Type type = 5;</code>
     */
    public fun clearType() {
      _builder.clearType()
    }
    /**
     * <pre>
     * If type_name is set, this need not be set.  If both this and type_name
     * are set, this must be one of TYPE_ENUM, TYPE_MESSAGE or TYPE_GROUP.
     * </pre>
     *
     * <code>optional .google.protobuf.FieldDescriptorProto.Type type = 5;</code>
     * @return Whether the type field is set.
     */
    public fun hasType(): kotlin.Boolean {
      return _builder.hasType()
    }

    /**
     * <pre>
     * For message and enum types, this is the name of the type.  If the name
     * starts with a '.', it is fully-qualified.  Otherwise, C++-like scoping
     * rules are used to find the type (i.e. first the nested types within this
     * message are searched, then within the parent, on up to the root
     * namespace).
     * </pre>
     *
     * <code>optional string type_name = 6;</code>
     */
    public var typeName: kotlin.String
      @JvmName("getTypeName")
      get() = _builder.getTypeName()
      @JvmName("setTypeName")
      set(value) {
        _builder.setTypeName(value)
      }
    /**
     * <pre>
     * For message and enum types, this is the name of the type.  If the name
     * starts with a '.', it is fully-qualified.  Otherwise, C++-like scoping
     * rules are used to find the type (i.e. first the nested types within this
     * message are searched, then within the parent, on up to the root
     * namespace).
     * </pre>
     *
     * <code>optional string type_name = 6;</code>
     */
    public fun clearTypeName() {
      _builder.clearTypeName()
    }
    /**
     * <pre>
     * For message and enum types, this is the name of the type.  If the name
     * starts with a '.', it is fully-qualified.  Otherwise, C++-like scoping
     * rules are used to find the type (i.e. first the nested types within this
     * message are searched, then within the parent, on up to the root
     * namespace).
     * </pre>
     *
     * <code>optional string type_name = 6;</code>
     * @return Whether the typeName field is set.
     */
    public fun hasTypeName(): kotlin.Boolean {
      return _builder.hasTypeName()
    }

    /**
     * <pre>
     * For extensions, this is the name of the type being extended.  It is
     * resolved in the same manner as type_name.
     * </pre>
     *
     * <code>optional string extendee = 2;</code>
     */
    public var extendee: kotlin.String
      @JvmName("getExtendee")
      get() = _builder.getExtendee()
      @JvmName("setExtendee")
      set(value) {
        _builder.setExtendee(value)
      }
    /**
     * <pre>
     * For extensions, this is the name of the type being extended.  It is
     * resolved in the same manner as type_name.
     * </pre>
     *
     * <code>optional string extendee = 2;</code>
     */
    public fun clearExtendee() {
      _builder.clearExtendee()
    }
    /**
     * <pre>
     * For extensions, this is the name of the type being extended.  It is
     * resolved in the same manner as type_name.
     * </pre>
     *
     * <code>optional string extendee = 2;</code>
     * @return Whether the extendee field is set.
     */
    public fun hasExtendee(): kotlin.Boolean {
      return _builder.hasExtendee()
    }

    /**
     * <pre>
     * For numeric types, contains the original text representation of the value.
     * For booleans, "true" or "false".
     * For strings, contains the default text contents (not escaped in any way).
     * For bytes, contains the C escaped value.  All bytes &gt;= 128 are escaped.
     * TODO(kenton):  Base-64 encode?
     * </pre>
     *
     * <code>optional string default_value = 7;</code>
     */
    public var defaultValue: kotlin.String
      @JvmName("getDefaultValue")
      get() = _builder.getDefaultValue()
      @JvmName("setDefaultValue")
      set(value) {
        _builder.setDefaultValue(value)
      }
    /**
     * <pre>
     * For numeric types, contains the original text representation of the value.
     * For booleans, "true" or "false".
     * For strings, contains the default text contents (not escaped in any way).
     * For bytes, contains the C escaped value.  All bytes &gt;= 128 are escaped.
     * TODO(kenton):  Base-64 encode?
     * </pre>
     *
     * <code>optional string default_value = 7;</code>
     */
    public fun clearDefaultValue() {
      _builder.clearDefaultValue()
    }
    /**
     * <pre>
     * For numeric types, contains the original text representation of the value.
     * For booleans, "true" or "false".
     * For strings, contains the default text contents (not escaped in any way).
     * For bytes, contains the C escaped value.  All bytes &gt;= 128 are escaped.
     * TODO(kenton):  Base-64 encode?
     * </pre>
     *
     * <code>optional string default_value = 7;</code>
     * @return Whether the defaultValue field is set.
     */
    public fun hasDefaultValue(): kotlin.Boolean {
      return _builder.hasDefaultValue()
    }

    /**
     * <pre>
     * If set, gives the index of a oneof in the containing type's oneof_decl
     * list.  This field is a member of that oneof.
     * </pre>
     *
     * <code>optional int32 oneof_index = 9;</code>
     */
    public var oneofIndex: kotlin.Int
      @JvmName("getOneofIndex")
      get() = _builder.getOneofIndex()
      @JvmName("setOneofIndex")
      set(value) {
        _builder.setOneofIndex(value)
      }
    /**
     * <pre>
     * If set, gives the index of a oneof in the containing type's oneof_decl
     * list.  This field is a member of that oneof.
     * </pre>
     *
     * <code>optional int32 oneof_index = 9;</code>
     */
    public fun clearOneofIndex() {
      _builder.clearOneofIndex()
    }
    /**
     * <pre>
     * If set, gives the index of a oneof in the containing type's oneof_decl
     * list.  This field is a member of that oneof.
     * </pre>
     *
     * <code>optional int32 oneof_index = 9;</code>
     * @return Whether the oneofIndex field is set.
     */
    public fun hasOneofIndex(): kotlin.Boolean {
      return _builder.hasOneofIndex()
    }

    /**
     * <pre>
     * JSON name of this field. The value is set by protocol compiler. If the
     * user has set a "json_name" option on this field, that option's value
     * will be used. Otherwise, it's deduced from the field's name by converting
     * it to camelCase.
     * </pre>
     *
     * <code>optional string json_name = 10;</code>
     */
    public var jsonName: kotlin.String
      @JvmName("getJsonName")
      get() = _builder.getJsonName()
      @JvmName("setJsonName")
      set(value) {
        _builder.setJsonName(value)
      }
    /**
     * <pre>
     * JSON name of this field. The value is set by protocol compiler. If the
     * user has set a "json_name" option on this field, that option's value
     * will be used. Otherwise, it's deduced from the field's name by converting
     * it to camelCase.
     * </pre>
     *
     * <code>optional string json_name = 10;</code>
     */
    public fun clearJsonName() {
      _builder.clearJsonName()
    }
    /**
     * <pre>
     * JSON name of this field. The value is set by protocol compiler. If the
     * user has set a "json_name" option on this field, that option's value
     * will be used. Otherwise, it's deduced from the field's name by converting
     * it to camelCase.
     * </pre>
     *
     * <code>optional string json_name = 10;</code>
     * @return Whether the jsonName field is set.
     */
    public fun hasJsonName(): kotlin.Boolean {
      return _builder.hasJsonName()
    }

    /**
     * <code>optional .google.protobuf.FieldOptions options = 8;</code>
     */
    public var options: com.google.protobuf.DescriptorProtos.FieldOptions
      @JvmName("getOptions")
      get() = _builder.getOptions()
      @JvmName("setOptions")
      set(value) {
        _builder.setOptions(value)
      }
    /**
     * <code>optional .google.protobuf.FieldOptions options = 8;</code>
     */
    public fun clearOptions() {
      _builder.clearOptions()
    }
    /**
     * <code>optional .google.protobuf.FieldOptions options = 8;</code>
     * @return Whether the options field is set.
     */
    public fun hasOptions(): kotlin.Boolean {
      return _builder.hasOptions()
    }

    /**
     * <pre>
     * If true, this is a proto3 "optional". When a proto3 field is optional, it
     * tracks presence regardless of field type.
     * When proto3_optional is true, this field must be belong to a oneof to
     * signal to old proto3 clients that presence is tracked for this field. This
     * oneof is known as a "synthetic" oneof, and this field must be its sole
     * member (each proto3 optional field gets its own synthetic oneof). Synthetic
     * oneofs exist in the descriptor only, and do not generate any API. Synthetic
     * oneofs must be ordered after all "real" oneofs.
     * For message fields, proto3_optional doesn't create any semantic change,
     * since non-repeated message fields always track presence. However it still
     * indicates the semantic detail of whether the user wrote "optional" or not.
     * This can be useful for round-tripping the .proto file. For consistency we
     * give message fields a synthetic oneof also, even though it is not required
     * to track presence. This is especially important because the parser can't
     * tell if a field is a message or an enum, so it must always create a
     * synthetic oneof.
     * Proto2 optional fields do not set this flag, because they already indicate
     * optional with `LABEL_OPTIONAL`.
     * </pre>
     *
     * <code>optional bool proto3_optional = 17;</code>
     */
    public var proto3Optional: kotlin.Boolean
      @JvmName("getProto3Optional")
      get() = _builder.getProto3Optional()
      @JvmName("setProto3Optional")
      set(value) {
        _builder.setProto3Optional(value)
      }
    /**
     * <pre>
     * If true, this is a proto3 "optional". When a proto3 field is optional, it
     * tracks presence regardless of field type.
     * When proto3_optional is true, this field must be belong to a oneof to
     * signal to old proto3 clients that presence is tracked for this field. This
     * oneof is known as a "synthetic" oneof, and this field must be its sole
     * member (each proto3 optional field gets its own synthetic oneof). Synthetic
     * oneofs exist in the descriptor only, and do not generate any API. Synthetic
     * oneofs must be ordered after all "real" oneofs.
     * For message fields, proto3_optional doesn't create any semantic change,
     * since non-repeated message fields always track presence. However it still
     * indicates the semantic detail of whether the user wrote "optional" or not.
     * This can be useful for round-tripping the .proto file. For consistency we
     * give message fields a synthetic oneof also, even though it is not required
     * to track presence. This is especially important because the parser can't
     * tell if a field is a message or an enum, so it must always create a
     * synthetic oneof.
     * Proto2 optional fields do not set this flag, because they already indicate
     * optional with `LABEL_OPTIONAL`.
     * </pre>
     *
     * <code>optional bool proto3_optional = 17;</code>
     */
    public fun clearProto3Optional() {
      _builder.clearProto3Optional()
    }
    /**
     * <pre>
     * If true, this is a proto3 "optional". When a proto3 field is optional, it
     * tracks presence regardless of field type.
     * When proto3_optional is true, this field must be belong to a oneof to
     * signal to old proto3 clients that presence is tracked for this field. This
     * oneof is known as a "synthetic" oneof, and this field must be its sole
     * member (each proto3 optional field gets its own synthetic oneof). Synthetic
     * oneofs exist in the descriptor only, and do not generate any API. Synthetic
     * oneofs must be ordered after all "real" oneofs.
     * For message fields, proto3_optional doesn't create any semantic change,
     * since non-repeated message fields always track presence. However it still
     * indicates the semantic detail of whether the user wrote "optional" or not.
     * This can be useful for round-tripping the .proto file. For consistency we
     * give message fields a synthetic oneof also, even though it is not required
     * to track presence. This is especially important because the parser can't
     * tell if a field is a message or an enum, so it must always create a
     * synthetic oneof.
     * Proto2 optional fields do not set this flag, because they already indicate
     * optional with `LABEL_OPTIONAL`.
     * </pre>
     *
     * <code>optional bool proto3_optional = 17;</code>
     * @return Whether the proto3Optional field is set.
     */
    public fun hasProto3Optional(): kotlin.Boolean {
      return _builder.hasProto3Optional()
    }
  }
}
@kotlin.jvm.JvmSynthetic
public inline fun com.google.protobuf.DescriptorProtos.FieldDescriptorProto.copy(block: com.google.protobuf.FieldDescriptorProtoKt.Dsl.() -> kotlin.Unit): com.google.protobuf.DescriptorProtos.FieldDescriptorProto =
  com.google.protobuf.FieldDescriptorProtoKt.Dsl._create(this.toBuilder()).apply { block() }._build()
